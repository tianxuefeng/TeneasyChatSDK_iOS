// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/tenant.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///线路选择
///0客服，1用户，2混合
public enum Api_Core_RoleRoute: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case worker // = 0
  case customer // = 1
  case all // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .worker
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .worker
    case 1: self = .customer
    case 2: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .worker: return 0
    case .customer: return 1
    case .all: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_Core_RoleRoute: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Api_Core_RoleRoute] = [
    .worker,
    .customer,
    .all,
  ]
}

#endif  // swift(>=4.2)

public struct Api_Core_RouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 角色id
  public var roleID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routeName: String = String()

  public var routeURL: String = String()

  public var routeRole: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_RouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routes: [Api_Core_RouteItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户名最多16个中文字符（字母、数字、特殊符号中包含两种）（必填）
  public var account: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_LoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  /// 客服信息
  public var items: Api_Common_Worker {
    get {return _items ?? Api_Common_Worker()}
    set {_items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return self._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {self._items = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _items: Api_Common_Worker? = nil
}

/// 登录下级账号
public struct Api_Core_ManagerLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_ManagerLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  /// 客服信息, 此处字段名和 LoginResponse 保持一致
  public var items: Api_Common_Worker {
    get {return _items ?? Api_Common_Worker()}
    set {_items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  public var hasItems: Bool {return self._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  public mutating func clearItems() {self._items = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _items: Api_Common_Worker? = nil
}

public struct Api_Core_TenantCreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户名 商户名称最少1位，最多16个字符
  public var name: String = String()

  /// 商户账号 用户名最少3位，最多16个字符
  public var account: String = String()

  /// 密码最少6位最多20个字符，至少包括字母、数字、特殊符号其中两种。
  public var password: String = String()

  /// 客服数量最高9999
  public var workerCapacity: Int32 = 0

  /// 每日接待人数
  public var dailyServiceCapacity: Int32 = 0

  /// 商户分组
  public var cliqueID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_TenantQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var groupID: Int32 = 0

  public var keyword: String = String()

  public var tenantItem: [Api_Core_TenantItem] = []

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_DeleteTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tenantID: UInt32 = 0

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_TenantItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  /// 商户绑定公钥
  public var tenantPublicKey: String = String()

  /// 商户名称
  public var name: String = String()

  /// 最大工作人员数量
  public var workersCapacity: Int32 = 0

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 = 0

  /// 入口数量
  public var entranceNum: Int32 = 0

  /// 用户名(商户账号)
  public var userName: String = String()

  /// 月均咨询量
  public var averageMonthly: Int32 = 0

  /// 累计咨询量
  public var cumulativeVolume: Int32 = 0

  /// 商户账号密码
  public var password: String = String()

  /// 创建时间
  public var createAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createAt = newValue}
  }
  /// Returns true if `createAt` has been explicitly set.
  public var hasCreateAt: Bool {return self._createAt != nil}
  /// Clears the value of `createAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreateAt() {self._createAt = nil}

  /// 删除时间（依次判断是否已删除）
  public var deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _deleteAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_deleteAt = newValue}
  }
  /// Returns true if `deleteAt` has been explicitly set.
  public var hasDeleteAt: Bool {return self._deleteAt != nil}
  /// Clears the value of `deleteAt`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteAt() {self._deleteAt = nil}

  /// 所在分组名称
  public var groupName: String = String()

  /// 所在分组名称
  public var cliqueID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deleteAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Api_Core_AdminLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_AdminLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拿到 token 后, 在需要鉴权的请求中填入Header, Key为X-Token
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: 修改商户登录账号和密码
public struct Api_Core_UpdateTenantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户id
  public var tenantID: UInt32 = 0

  /// 商户名称
  public var name: String = String()

  /// 客服数量
  public var workerCapacity: Int32 = 0

  /// 每日服务数量
  public var dailyServiceCapacity: Int32 = 0

  /// 商户账号密码(密码调整)
  public var password: String = String()

  /// 商户分组
  public var cliqueID: Int32 = 0

  /// 商户云信前缀
  public var nimprex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_PublicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///key
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_QueryTenantInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: Api_Core_TenantItem {
    get {return _item ?? Api_Core_TenantItem()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _item: Api_Core_TenantItem? = nil
}

/// TODO: 更新云信信息
public struct Api_Core_UpdateNimInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var nimid: String = String()

  public var nimsession: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_RoleRoute: @unchecked Sendable {}
extension Api_Core_RouteRequest: @unchecked Sendable {}
extension Api_Core_RouteItem: @unchecked Sendable {}
extension Api_Core_RouteResponse: @unchecked Sendable {}
extension Api_Core_LoginRequest: @unchecked Sendable {}
extension Api_Core_LoginResponse: @unchecked Sendable {}
extension Api_Core_ManagerLoginRequest: @unchecked Sendable {}
extension Api_Core_ManagerLoginResponse: @unchecked Sendable {}
extension Api_Core_TenantCreateRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryRequest: @unchecked Sendable {}
extension Api_Core_TenantQueryResponse: @unchecked Sendable {}
extension Api_Core_DeleteTenantRequest: @unchecked Sendable {}
extension Api_Core_TenantItem: @unchecked Sendable {}
extension Api_Core_AdminLoginRequest: @unchecked Sendable {}
extension Api_Core_AdminLoginResponse: @unchecked Sendable {}
extension Api_Core_UpdateTenantRequest: @unchecked Sendable {}
extension Api_Core_PublicKeyResponse: @unchecked Sendable {}
extension Api_Core_QueryTenantInfoResponse: @unchecked Sendable {}
extension Api_Core_UpdateNimInfoRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_RoleRoute: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Role_ROUTE_WORKER"),
    1: .same(proto: "Role_ROUTE_CUSTOMER"),
    2: .same(proto: "Role_ROUTE_ALL"),
  ]
}

extension Api_Core_RouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularInt32Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteRequest, rhs: Api_Core_RouteRequest) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_name"),
    2: .standard(proto: "route_url"),
    3: .standard(proto: "route_role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.routeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routeURL) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.routeRole) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routeName.isEmpty {
      try visitor.visitSingularStringField(value: self.routeName, fieldNumber: 1)
    }
    if !self.routeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.routeURL, fieldNumber: 2)
    }
    if self.routeRole != 0 {
      try visitor.visitSingularInt32Field(value: self.routeRole, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteItem, rhs: Api_Core_RouteItem) -> Bool {
    if lhs.routeName != rhs.routeName {return false}
    if lhs.routeURL != rhs.routeURL {return false}
    if lhs.routeRole != rhs.routeRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_RouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_RouteResponse, rhs: Api_Core_RouteResponse) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginRequest, rhs: Api_Core_LoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._items {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_LoginResponse, rhs: Api_Core_LoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._items != rhs._items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginRequest, rhs: Api_Core_ManagerLoginRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ManagerLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._items {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ManagerLoginResponse, rhs: Api_Core_ManagerLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._items != rhs._items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "account"),
    3: .same(proto: "password"),
    4: .standard(proto: "worker_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "clique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 4)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantCreateRequest, rhs: Api_Core_TenantCreateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryRequest, rhs: Api_Core_TenantQueryRequest) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "keyword"),
    4: .standard(proto: "tenant_item"),
    5: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tenantItem) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    if !self.tenantItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tenantItem, fieldNumber: 4)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantQueryResponse, rhs: Api_Core_TenantQueryResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.tenantItem != rhs.tenantItem {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_DeleteTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_DeleteTenantRequest, rhs: Api_Core_DeleteTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_TenantItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "tenant_public_key"),
    3: .same(proto: "name"),
    4: .standard(proto: "workers_capacity"),
    5: .standard(proto: "daily_service_capacity"),
    6: .standard(proto: "entrance_num"),
    7: .standard(proto: "user_name"),
    8: .standard(proto: "average_monthly"),
    9: .standard(proto: "cumulative_volume"),
    10: .same(proto: "password"),
    11: .standard(proto: "create_at"),
    12: .standard(proto: "delete_at"),
    13: .standard(proto: "group_name"),
    14: .standard(proto: "clique_Id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tenantPublicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.workersCapacity) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.entranceNum) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.averageMonthly) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.cumulativeVolume) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._createAt) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._deleteAt) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.tenantPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantPublicKey, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.workersCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workersCapacity, fieldNumber: 4)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 5)
    }
    if self.entranceNum != 0 {
      try visitor.visitSingularInt32Field(value: self.entranceNum, fieldNumber: 6)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 7)
    }
    if self.averageMonthly != 0 {
      try visitor.visitSingularInt32Field(value: self.averageMonthly, fieldNumber: 8)
    }
    if self.cumulativeVolume != 0 {
      try visitor.visitSingularInt32Field(value: self.cumulativeVolume, fieldNumber: 9)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 10)
    }
    try { if let v = self._createAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._deleteAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 13)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_TenantItem, rhs: Api_Core_TenantItem) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.tenantPublicKey != rhs.tenantPublicKey {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workersCapacity != rhs.workersCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.entranceNum != rhs.entranceNum {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.averageMonthly != rhs.averageMonthly {return false}
    if lhs.cumulativeVolume != rhs.cumulativeVolume {return false}
    if lhs.password != rhs.password {return false}
    if lhs._createAt != rhs._createAt {return false}
    if lhs._deleteAt != rhs._deleteAt {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginRequest, rhs: Api_Core_AdminLoginRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_AdminLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_AdminLoginResponse, rhs: Api_Core_AdminLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateTenantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTenantRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "worker_capacity"),
    4: .standard(proto: "daily_service_capacity"),
    5: .same(proto: "password"),
    6: .standard(proto: "clique_id"),
    7: .same(proto: "nimprex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.workerCapacity) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.dailyServiceCapacity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.cliqueID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nimprex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularUInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.workerCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.workerCapacity, fieldNumber: 3)
    }
    if self.dailyServiceCapacity != 0 {
      try visitor.visitSingularInt32Field(value: self.dailyServiceCapacity, fieldNumber: 4)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 5)
    }
    if self.cliqueID != 0 {
      try visitor.visitSingularInt32Field(value: self.cliqueID, fieldNumber: 6)
    }
    if !self.nimprex.isEmpty {
      try visitor.visitSingularStringField(value: self.nimprex, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateTenantRequest, rhs: Api_Core_UpdateTenantRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.workerCapacity != rhs.workerCapacity {return false}
    if lhs.dailyServiceCapacity != rhs.dailyServiceCapacity {return false}
    if lhs.password != rhs.password {return false}
    if lhs.cliqueID != rhs.cliqueID {return false}
    if lhs.nimprex != rhs.nimprex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_PublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_PublicKeyResponse, rhs: Api_Core_PublicKeyResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_QueryTenantInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTenantInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_QueryTenantInfoResponse, rhs: Api_Core_QueryTenantInfoResponse) -> Bool {
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_UpdateNimInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNimInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workerId"),
    2: .same(proto: "nimid"),
    3: .same(proto: "nimsession"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nimid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nimsession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.nimid.isEmpty {
      try visitor.visitSingularStringField(value: self.nimid, fieldNumber: 2)
    }
    if !self.nimsession.isEmpty {
      try visitor.visitSingularStringField(value: self.nimsession, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_UpdateNimInfoRequest, rhs: Api_Core_UpdateNimInfoRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.nimid != rhs.nimid {return false}
    if lhs.nimsession != rhs.nimsession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
