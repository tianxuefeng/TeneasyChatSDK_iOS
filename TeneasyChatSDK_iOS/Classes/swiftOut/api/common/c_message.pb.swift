// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/common/c_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum CommonChatState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// 一线任务
  case common // = 0

  /// 转接任务
  case transfer // = 1

  /// 2-4 前端处理(细拆一线任务: 3分钟待回复, 已超时待回复, 已接待)
  /// 未接待-3分钟内
  case unprocessed3Min // = 2

  /// 未接待-3分钟外(已超时)
  case timeout // = 3

  /// 已接待
  case processed // = 4

  /// 黑名单待处理
  case unconfirmed // = 5

  /// 黑名单
  case confirmed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .common
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .common
    case 1: self = .transfer
    case 2: self = .unprocessed3Min
    case 3: self = .timeout
    case 4: self = .processed
    case 5: self = .unconfirmed
    case 6: self = .confirmed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .common: return 0
    case .transfer: return 1
    case .unprocessed3Min: return 2
    case .timeout: return 3
    case .processed: return 4
    case .unconfirmed: return 5
    case .confirmed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonChatState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CommonChatState] = [
    .common,
    .transfer,
    .unprocessed3Min,
    .timeout,
    .processed,
    .unconfirmed,
    .confirmed,
  ]
}

#endif  // swift(>=4.2)

/// 消息类型
enum CommonMessageFormat: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// 文本
  case msgText // = 0

  /// 图片
  case msgImg // = 1

  /// voice
  case msgVoice // = 2

  /// 视频
  case msgVideo // = 3

  /// 地理位置
  case msgGeo // = 4

  /// 文件
  case msgFile // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .msgText
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgText
    case 1: self = .msgImg
    case 2: self = .msgVoice
    case 3: self = .msgVideo
    case 4: self = .msgGeo
    case 6: self = .msgFile
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .msgText: return 0
    case .msgImg: return 1
    case .msgVoice: return 2
    case .msgVideo: return 3
    case .msgGeo: return 4
    case .msgFile: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CommonMessageFormat] = [
    .msgText,
    .msgImg,
    .msgVoice,
    .msgVideo,
    .msgGeo,
    .msgFile,
  ]
}

#endif  // swift(>=4.2)

/// 消息拥有者角色
enum CommonMessageRole: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// 系统服务
  case msgRoleSystem // = 0

  /// 商户客服工作者
  case msgRoleWorker // = 1

  /// 商户客户
  case msgRoleCustomer // = 2

  /// 商户临时客户 (h5接入)
  case msgRoleAnonymous // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .msgRoleSystem
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgRoleSystem
    case 1: self = .msgRoleWorker
    case 2: self = .msgRoleCustomer
    case 3: self = .msgRoleAnonymous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .msgRoleSystem: return 0
    case .msgRoleWorker: return 1
    case .msgRoleCustomer: return 2
    case .msgRoleAnonymous: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CommonMessageRole] = [
    .msgRoleSystem,
    .msgRoleWorker,
    .msgRoleCustomer,
    .msgRoleAnonymous,
  ]
}

#endif  // swift(>=4.2)

enum CommonMessageOperate: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// (默认)发送
  case msgOpPost // = 0

  /// 编辑消息
  case msgOpEdit // = 1

  /// 撤回消息
  case msgOpDelete // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .msgOpPost
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgOpPost
    case 1: self = .msgOpEdit
    case 2: self = .msgOpDelete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .msgOpPost: return 0
    case .msgOpEdit: return 1
    case .msgOpDelete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CommonMessageOperate: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CommonMessageOperate] = [
    .msgOpPost,
    .msgOpEdit,
    .msgOpDelete,
  ]
}

#endif  // swift(>=4.2)

/// 文本消息内容
struct CommonMessageContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 内容
  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 图片
struct CommonMessageImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  var uri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 音频
struct CommonMessageAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  var uri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 视频
struct CommonMessageVideo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  var uri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 地理位置
struct CommonMessageGeo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longitude: String = String()

  var latitude: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 文件
struct CommonMessageFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 不包括host部分
  var uri: String = String()

  /// 文件名, 去掉目录部分
  var fileName: String = String()

  /// 文件大小
  var size: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CommonMessageKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chatID: Int64 = 0

  var msgID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CommonMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 会话id(指此次聊天会话的id, 实际上是 终端用户 的 client id)
  /// 此处避免与连接session混淆, 用chat id区分
  /// 对于终端用户(h5, web), 无视此字段(服务端填入)
  /// 对于客服(pc), 发消息时填对应会话的id
  /// 对于持久化, 可作为 分区 id
  var chatID: Int64 = 0

  /// 消息id, 服务端分配
  var msgID: Int64 = 0

  /// 消息发送时间, 服务端分配
  var msgTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _msgTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_msgTime = newValue}
  }
  /// Returns true if `msgTime` has been explicitly set.
  var hasMsgTime: Bool {return self._msgTime != nil}
  /// Clears the value of `msgTime`. Subsequent reads from it will return its default value.
  mutating func clearMsgTime() {self._msgTime = nil}

  /// 发送人, 服务端记录
  /// 发送人为0 = 系统消息
  var sender: Int64 = 0

  /// 回复消息
  var replyMsgID: Int64 = 0

  /// 消息操作人
  var msgOp: CommonMessageOperate = .msgOpPost

  /// 分配客服id
  var worker: Int32 = 0

  var payload: CommonMessage.OneOf_Payload? = nil

  var content: CommonMessageContent {
    get {
      if case .content(let v)? = payload {return v}
      return CommonMessageContent()
    }
    set {payload = .content(newValue)}
  }

  var image: CommonMessageImage {
    get {
      if case .image(let v)? = payload {return v}
      return CommonMessageImage()
    }
    set {payload = .image(newValue)}
  }

  var audio: CommonMessageAudio {
    get {
      if case .audio(let v)? = payload {return v}
      return CommonMessageAudio()
    }
    set {payload = .audio(newValue)}
  }

  var video: CommonMessageVideo {
    get {
      if case .video(let v)? = payload {return v}
      return CommonMessageVideo()
    }
    set {payload = .video(newValue)}
  }

  var geo: CommonMessageGeo {
    get {
      if case .geo(let v)? = payload {return v}
      return CommonMessageGeo()
    }
    set {payload = .geo(newValue)}
  }

  var file: CommonMessageFile {
    get {
      if case .file(let v)? = payload {return v}
      return CommonMessageFile()
    }
    set {payload = .file(newValue)}
  }

  /// 已转接至客服 xxx
  var workerTrans: CommonWorkerTransfer {
    get {
      if case .workerTrans(let v)? = payload {return v}
      return CommonWorkerTransfer()
    }
    set {payload = .workerTrans(newValue)}
  }

  /// 请求将此会话拉入黑名单
  var blacklistApply: CommonBlackListApply {
    get {
      if case .blacklistApply(let v)? = payload {return v}
      return CommonBlackListApply()
    }
    set {payload = .blacklistApply(newValue)}
  }

  /// 确认拉入黑名单
  var blacklistConfirm: CommonBlackListConfirm {
    get {
      if case .blacklistConfirm(let v)? = payload {return v}
      return CommonBlackListConfirm()
    }
    set {payload = .blacklistConfirm(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case content(CommonMessageContent)
    case image(CommonMessageImage)
    case audio(CommonMessageAudio)
    case video(CommonMessageVideo)
    case geo(CommonMessageGeo)
    case file(CommonMessageFile)
    /// 已转接至客服 xxx
    case workerTrans(CommonWorkerTransfer)
    /// 请求将此会话拉入黑名单
    case blacklistApply(CommonBlackListApply)
    /// 确认拉入黑名单
    case blacklistConfirm(CommonBlackListConfirm)

  #if !swift(>=4.1)
    static func ==(lhs: CommonMessage.OneOf_Payload, rhs: CommonMessage.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geo, .geo): return {
        guard case .geo(let l) = lhs, case .geo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workerTrans, .workerTrans): return {
        guard case .workerTrans(let l) = lhs, case .workerTrans(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blacklistApply, .blacklistApply): return {
        guard case .blacklistApply(let l) = lhs, case .blacklistApply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blacklistConfirm, .blacklistConfirm): return {
        guard case .blacklistConfirm(let l) = lhs, case .blacklistConfirm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _msgTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CommonWorkerTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workerID: Int32 = 0

  var workerName: String = String()

  var workerAvatar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 请求拉入黑名单
struct CommonBlackListApply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 目标客服
  /// 目标客服 需有 操作黑名单权限
  var workerID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 确认拉入黑名单
struct CommonBlackListConfirm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作客服
  var workerID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CommonChatState: @unchecked Sendable {}
extension CommonMessageFormat: @unchecked Sendable {}
extension CommonMessageRole: @unchecked Sendable {}
extension CommonMessageOperate: @unchecked Sendable {}
extension CommonMessageContent: @unchecked Sendable {}
extension CommonMessageImage: @unchecked Sendable {}
extension CommonMessageAudio: @unchecked Sendable {}
extension CommonMessageVideo: @unchecked Sendable {}
extension CommonMessageGeo: @unchecked Sendable {}
extension CommonMessageFile: @unchecked Sendable {}
extension CommonMessageKey: @unchecked Sendable {}
extension CommonMessage: @unchecked Sendable {}
extension CommonMessage.OneOf_Payload: @unchecked Sendable {}
extension CommonWorkerTransfer: @unchecked Sendable {}
extension CommonBlackListApply: @unchecked Sendable {}
extension CommonBlackListConfirm: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.common"

extension CommonChatState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT_STATE_COMMON"),
    1: .same(proto: "CHAT_STATE_TRANSFER"),
    2: .same(proto: "CHAT_STATE_UNPROCESSED_3MIN"),
    3: .same(proto: "CHAT_STATE_TIMEOUT"),
    4: .same(proto: "CHAT_STATE_PROCESSED"),
    5: .same(proto: "CHAT_STATE_UNCONFIRMED"),
    6: .same(proto: "CHAT_STATE_CONFIRMED"),
  ]
}

extension CommonMessageFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_TEXT"),
    1: .same(proto: "MSG_IMG"),
    2: .same(proto: "MSG_VOICE"),
    3: .same(proto: "MSG_VIDEO"),
    4: .same(proto: "MSG_GEO"),
    6: .same(proto: "MSG_FILE"),
  ]
}

extension CommonMessageRole: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_ROLE_SYSTEM"),
    1: .same(proto: "MSG_ROLE_WORKER"),
    2: .same(proto: "MSG_ROLE_CUSTOMER"),
    3: .same(proto: "MSG_ROLE_ANONYMOUS"),
  ]
}

extension CommonMessageOperate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_OP_POST"),
    1: .same(proto: "MSG_OP_EDIT"),
    2: .same(proto: "MSG_OP_DELETE"),
  ]
}

extension CommonMessageContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageContent, rhs: CommonMessageContent) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageImage, rhs: CommonMessageImage) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageAudio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageAudio, rhs: CommonMessageAudio) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageVideo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageVideo, rhs: CommonMessageVideo) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageGeo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageGeo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.longitude) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.longitude.isEmpty {
      try visitor.visitSingularStringField(value: self.longitude, fieldNumber: 1)
    }
    if !self.latitude.isEmpty {
      try visitor.visitSingularStringField(value: self.latitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageGeo, rhs: CommonMessageGeo) -> Bool {
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "file_name"),
    3: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageFile, rhs: CommonMessageFile) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "msg_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.msgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.msgID != 0 {
      try visitor.visitSingularInt64Field(value: self.msgID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessageKey, rhs: CommonMessageKey) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "msg_id"),
    3: .standard(proto: "msg_time"),
    4: .same(proto: "sender"),
    5: .standard(proto: "reply_msg_id"),
    6: .standard(proto: "msg_op"),
    7: .same(proto: "worker"),
    100: .same(proto: "content"),
    101: .same(proto: "image"),
    102: .same(proto: "audio"),
    103: .same(proto: "video"),
    104: .same(proto: "geo"),
    105: .same(proto: "file"),
    106: .standard(proto: "worker_trans"),
    107: .standard(proto: "blacklist_apply"),
    108: .standard(proto: "blacklist_confirm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.msgID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._msgTime) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sender) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.replyMsgID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.msgOp) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.worker) }()
      case 100: try {
        var v: CommonMessageContent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .content(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .content(v)
        }
      }()
      case 101: try {
        var v: CommonMessageImage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .image(v)
        }
      }()
      case 102: try {
        var v: CommonMessageAudio?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .audio(v)
        }
      }()
      case 103: try {
        var v: CommonMessageVideo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .video(v)
        }
      }()
      case 104: try {
        var v: CommonMessageGeo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .geo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .geo(v)
        }
      }()
      case 105: try {
        var v: CommonMessageFile?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .file(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .file(v)
        }
      }()
      case 106: try {
        var v: CommonWorkerTransfer?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .workerTrans(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .workerTrans(v)
        }
      }()
      case 107: try {
        var v: CommonBlackListApply?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .blacklistApply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .blacklistApply(v)
        }
      }()
      case 108: try {
        var v: CommonBlackListConfirm?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .blacklistConfirm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .blacklistConfirm(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.msgID != 0 {
      try visitor.visitSingularInt64Field(value: self.msgID, fieldNumber: 2)
    }
    try { if let v = self._msgTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.sender != 0 {
      try visitor.visitSingularInt64Field(value: self.sender, fieldNumber: 4)
    }
    if self.replyMsgID != 0 {
      try visitor.visitSingularInt64Field(value: self.replyMsgID, fieldNumber: 5)
    }
    if self.msgOp != .msgOpPost {
      try visitor.visitSingularEnumField(value: self.msgOp, fieldNumber: 6)
    }
    if self.worker != 0 {
      try visitor.visitSingularInt32Field(value: self.worker, fieldNumber: 7)
    }
    switch self.payload {
    case .content?: try {
      guard case .content(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .image?: try {
      guard case .image(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .video?: try {
      guard case .video(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .geo?: try {
      guard case .geo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .file?: try {
      guard case .file(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .workerTrans?: try {
      guard case .workerTrans(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .blacklistApply?: try {
      guard case .blacklistApply(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .blacklistConfirm?: try {
      guard case .blacklistConfirm(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonMessage, rhs: CommonMessage) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs._msgTime != rhs._msgTime {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.replyMsgID != rhs.replyMsgID {return false}
    if lhs.msgOp != rhs.msgOp {return false}
    if lhs.worker != rhs.worker {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonWorkerTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorkerTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "worker_name"),
    3: .standard(proto: "worker_avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workerName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workerAvatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.workerName.isEmpty {
      try visitor.visitSingularStringField(value: self.workerName, fieldNumber: 2)
    }
    if !self.workerAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.workerAvatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonWorkerTransfer, rhs: CommonWorkerTransfer) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.workerName != rhs.workerName {return false}
    if lhs.workerAvatar != rhs.workerAvatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonBlackListApply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlackListApply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonBlackListApply, rhs: CommonBlackListApply) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommonBlackListConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlackListConfirm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommonBlackListConfirm, rhs: CommonBlackListConfirm) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
